## 自动拧钉系统——研发说明

本文针将对自动拧钉系统中各个功能的研发思路进行分析以及解释现有程序

### 一、 基于python的控制系统

此控制系统主要实现的功能为：

1. 整合duco协作臂，hik相机，danikor电批，以及主控上位机等软硬件；
2. 对hik相机的计算结果进行解算并传给duco协作臂；
3. 对danikor电批进行控制并读出力矩数据反馈给主控上位机。

*具体算法详情就开发场景进行修改，本说明仅提供对各个功能模块的研发思路！*

#### 1. py_ctrler

用于执行整合任务的服务端线程，在此创建一个单独端口的服务端

```python
# 创建socket对象
py_server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

# 绑定端口
py_server.bind((host,py_port)) # 此处的port在变量中应先定义为与其他服务端不同的端口
```

duco协作臂与主控上位机分别与此服务端连接，此步骤中需要严格确保连接的先后顺序应该为***先协作臂后上位机***

```python
# 设置最大连接数，超过后排队
py_server.listen(2)
print('py_ctrler: 等待客户端连接 ! ! !')

cobot, addr_B = py_server.accept()
print(f"py_ctrler: 协作臂已连接，地址: {addr_B}")

ctrl_system, addr_A = py_server.accept()
print(f"py_ctrler: 主控系统已连接，地址: {addr_A}")
```

等待上位机发来的数据并转发给duco协作臂

```python
data = ctrl_system.recv(1024).decode('utf-8')

cobot.sendall(data.encode('utf-8'))
```



#### 2. cam_ctrler

作为协作臂与hik相机的中继，主要目的是代替协作臂对相机识别反馈的结果进行解算。

在此先创立一个单独端口的服务端等待与协作臂的连接

```python
    # 创建socket对象
    cam_server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

    # 绑定端口
    cam_server.bind((host,cam_port))

    # 设置最大连接数，超过后排队
    cam_server.listen(1)
    print('cam_ctrler: 等待协作臂连接 ! ! !')

    cobot, addr_B = cam_server.accept()
    print(f"cam_ctrler: 协作臂已连接，地址: {addr_B}")
```

此后进入循环，并等待协作臂传来的触发信号

```python
print("cam_ctrler: 等待触发信号 ! ! !")

data = cobot.recv(1024).decode('utf-8')
```

当整套系统需要进行拍照识别的时候，只需要发送方案名称，cam_ctrler系统执行切换方案、指令拍照、结果识别的所有任务；

若有不同的识别方案，则需要提供不同的圆孔比例尺识别尺寸，本程序中均采用的圆形模板半径作为尺寸基准，hik.GetHikDPos的函数解析详见《函数开发手册》

```python
# 切换方案
IsSwitchPlanSuccessful = hik.SetHikSwitchPlan('switch', data)
if IsSwitchPlanSuccessful == 0:
    print("cam_ctrler: 切换方案失败")
    return 0
if data == "M6FindScrew":
    DPos = hik.GetHikDPos(M6ScrewDiameter)
elif data == "M6FindHole":
    DPos = hik.GetHikDPos(M6HoleDiameter)
elif data == "M4FindScrew":
    DPos = hik.GetHikDPos(M4ScrewDiameter)
elif data == "M4FindHole":
    DPos = hik.GetHikDPos(M4HoleDiameter)
```

随后根据协作臂的解析需求，向协作臂发送解析数据

```python
str_DPos = '(' + str(DPos[0]) + ',' + str(DPos[1]) + ')'
cobot.sendall(str_DPos.encode('utf-8'))
```



#### 4. bit_ctrler

同样作为协作臂与电批控制器之间的中继服务端承接指令与回传结果。

在此先创立一个单独端口的服务端等待与协作臂的连接

```python
# 创建socket对象
bit_server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

# 绑定端口
bit_server.bind((host,bit_port))

# 设置最大连接数，超过后排队
bit_server.listen(1)
print('bit_ctrler: 等待协作臂连接 ! ! !')

cobot, addr_B = bit_server.accept()
print(f"bit_ctrler: 协作臂已连接，地址: {addr_B}")
```

同样的，等待协作臂传来启动电批的指令信号

```python
print("bit_ctrler: 等待触发信号 ! ! !")
data = cobot.recv(1024).decode('utf-8')
```

针对此时需要执行的任务，向本中继服务端发送方案指令

```python
if data == "rot_bit_inv":
    danikor.ScrewMotorCtrl(2)
elif data == "M6_rot_bit":
    result = danikor.ScrewMotorCtrl(3)
    cobot.sendall(str(result[0]).encode('utf-8'))
    print('bit_ctrler: 拧紧力矩为 ', result[0], "Nm")
elif data == "M4_rot_bit":
    result = danikor.ScrewMotorCtrl(1)
    cobot.sendall(str(result[0]).encode('utf-8'))
    print('bit_ctrler: 拧紧力矩为 ', result[0], "Nm")
```

### 二、基于协作臂本体的控制逻辑

有关协作臂运动的所有运动相关，逻辑相关的，以及内部io控制相关的执行逻辑程序均在协作臂本体的可视化编程中进行，可以将各个功能模块化，从而在整体任务程序中通过对子程序的嵌套来实现任务流程。



